<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>FlowGraph Input Architecture Design | FlowGraph </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="FlowGraph Input Architecture Design | FlowGraph ">
      
      
      <link rel="icon" href="favicon.ico">
      <link rel="stylesheet" href="public/docfx.min.css">
      <link rel="stylesheet" href="public/main.css">
      <meta name="docfx:navrel" content="toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="">
      
      
      <meta name="docfx:docurl" content="https://github.com/prismify-co/FlowGraph/blob/master/docs/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="index.html">
            <img id="logo" class="svg" src="logo.svg" alt="FlowGraph">
            FlowGraph
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">

      <div class="content">
        <div class="actionbar">

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="flowgraph-input-architecture-design">FlowGraph Input Architecture Design</h1>

<h2 id="executive-summary">Executive Summary</h2>
<p>This document proposes a <strong>hybrid input architecture</strong> that combines:</p>
<ul>
<li><strong>InputProcessor pattern</strong> (Nodify-inspired) as the core state machine</li>
<li><strong>Behavior pattern</strong> (Blazor.Diagrams-inspired) as an optional extensibility layer</li>
</ul>
<p>The goal is to eliminate the fragile pattern-matching in <code>IdleState</code> while maintaining the clean state machine approach and enabling user-defined behaviors.</p>
<hr>
<h2 id="problem-analysis">Problem Analysis</h2>
<h3 id="current-architecture-what-we-have">Current Architecture (What We Have)</h3>
<pre><code>FlowCanvas.Input.cs                 InputStateMachine
       │                                   │
       │ OnRootPanelPointerPressed()       │
       │                                   │
       ├─► Hit test (direct or visual)     │
       │                                   │
       │   Returns: Control with Tag       │
       │                                   │
       └─► _inputStateMachine              │
              .HandlePointerPressed(e, hitElement)
                       │
                       ▼
               IdleState.HandlePointerPressed()
                       │
         ┌─────────────┼─────────────┐
         │             │             │
    Pattern Match on Tag:            │
    ─ Node?           ─ Edge?        │
    ─ (Node,Port,bool)? ─ (Node,ResizeHandlePosition)?
    ─ (ShapeElement,ResizeHandlePosition)?
    ─ ShapeElement?
</code></pre>
<p><strong>The Problem:</strong> Every new element type or sub-element requires:</p>
<ol>
<li>New pattern in <code>IdleState</code></li>
<li>New handler method</li>
<li>Easy to forget (the resize handle bug we just fixed)</li>
</ol>
<h3 id="why-pattern-matching-is-fragile">Why Pattern Matching is Fragile</h3>
<pre><code class="lang-csharp">// IdleState.cs - Current approach (fragile)
if (source?.Tag is (Node resizeNode, ResizeHandlePosition handlePos))
    return HandleResizeHandleClick(...);

if (source?.Tag is (ShapeElement resizeShape, ResizeHandlePosition shapeHandlePos))  // &lt;-- EASY TO FORGET!
    return HandleShapeResizeHandleClick(...);
</code></pre>
<p>Each element type needs its own pattern. Miss one = silent failure (falls through to canvas click).</p>
<hr>
<h2 id="proposed-architecture">Proposed Architecture</h2>
<h3 id="layer-1-core-state-machine-inputprocessor-pattern">Layer 1: Core State Machine (InputProcessor Pattern)</h3>
<p>The state machine remains the core orchestrator, but instead of pattern matching on Tags, it dispatches to <strong>registered InputProcessors</strong>.</p>
<pre><code>                    ┌─────────────────────────────────────────────┐
                    │              InputStateMachine               │
                    │  ┌─────────────────────────────────────┐    │
                    │  │         InputDispatcher              │    │
                    │  │                                      │    │
                    │  │  HitTest() ──► GraphHitTestResult    │    │
                    │  │       │                              │    │
                    │  │       ▼                              │    │
                    │  │  Route to InputProcessor             │    │
                    │  │       │                              │    │
                    │  │       ▼                              │    │
                    │  │  Processor handles OR               │    │
                    │  │  Processor transitions state         │    │
                    │  └─────────────────────────────────────┘    │
                    │                                             │
                    │  States: Idle, Dragging, Panning, etc.     │
                    └─────────────────────────────────────────────┘
</code></pre>
<h3 id="layer-2-inputprocessors-per-element-handlers">Layer 2: InputProcessors (Per-Element Handlers)</h3>
<p>Each element type has a dedicated processor that knows how to handle its input:</p>
<pre><code class="lang-csharp">// FlowGraph.Avalonia/Input/Processors/IInputProcessor.cs
public interface IInputProcessor
{
    /// &lt;summary&gt;
    /// The hit target type(s) this processor handles.
    /// &lt;/summary&gt;
    IReadOnlyList&lt;HitTargetType&gt; HandledTypes { get; }

    /// &lt;summary&gt;
    /// Priority for handling. Higher = checked first.
    /// Resize handles &gt; Ports &gt; Nodes &gt; Edges &gt; Canvas
    /// &lt;/summary&gt;
    int Priority { get; }

    /// &lt;summary&gt;
    /// Handles pointer pressed on this element type.
    /// &lt;/summary&gt;
    InputProcessorResult HandlePointerPressed(
        InputStateContext context,
        GraphHitTestResult hitResult,
        PointerPressedEventArgs e);

    // Similar for Move, Release, etc.
}

public record InputProcessorResult(
    IInputState? NewState,      // Transition to new state?
    bool Handled,               // Stop propagation?
    bool ContinueToNext = false // Also let next processor handle?
);
</code></pre>
<h3 id="layer-3-behaviors-optional-extensibility">Layer 3: Behaviors (Optional Extensibility)</h3>
<p>Behaviors are user-facing extensions that can observe and optionally intercept input:</p>
<pre><code class="lang-csharp">// FlowGraph.Core/Input/IBehavior.cs (framework-agnostic)
public interface IBehavior
{
    /// &lt;summary&gt;
    /// Display name for debugging/UI.
    /// &lt;/summary&gt;
    string Name { get; }

    /// &lt;summary&gt;
    /// Whether this behavior is currently active.
    /// &lt;/summary&gt;
    bool IsEnabled { get; set; }

    /// &lt;summary&gt;
    /// Called before standard processing. Can intercept.
    /// &lt;/summary&gt;
    BehaviorResult OnPointerPressed(IGraphInputEvent e);

    /// &lt;summary&gt;
    /// Called after standard processing completes.
    /// &lt;/summary&gt;
    void OnPointerPressedComplete(IGraphInputEvent e);
}

public record BehaviorResult(bool Handled, bool SuppressDefault = false);
</code></pre>
<hr>
<h2 id="detailed-design">Detailed Design</h2>
<h3 id="1-graphhittestresult-integration">1. GraphHitTestResult Integration</h3>
<p>The existing <code>IGraphHitTester</code> + <code>GraphHitTestResult</code> in FlowGraph.Core is <strong>perfect</strong> for this:</p>
<pre><code class="lang-csharp">// Already exists in FlowGraph.Core/Input/IGraphHitTester.cs
public class GraphHitTestResult
{
    public HitTargetType TargetType { get; init; }
    public object? Target { get; init; }
    public Point CanvasPosition { get; init; }

    // Typed accessors
    public Node? Node =&gt; ...;
    public Edge? Edge =&gt; ...;
    public Port? Port =&gt; ...;
    public ResizeHandlePosition? ResizeHandle =&gt; ...;
}
</code></pre>
<p><strong>This eliminates pattern matching!</strong> The hit test result already knows what type was hit.</p>
<h3 id="2-inputdispatcher-new">2. InputDispatcher (New)</h3>
<p>Replaces the pattern matching in IdleState:</p>
<pre><code class="lang-csharp">// FlowGraph.Avalonia/Input/InputDispatcher.cs
public class InputDispatcher
{
    private readonly IGraphHitTester _hitTester;
    private readonly List&lt;IInputProcessor&gt; _processors;
    private readonly List&lt;IBehavior&gt; _behaviors;

    public InputDispatcher(IGraphHitTester hitTester)
    {
        _hitTester = hitTester;
        _processors = new List&lt;IInputProcessor&gt;();
        _behaviors = new List&lt;IBehavior&gt;();

        // Register built-in processors in priority order
        RegisterProcessor(new ResizeHandleProcessor());  // Priority: 100
        RegisterProcessor(new PortProcessor());           // Priority: 90
        RegisterProcessor(new NodeProcessor());           // Priority: 80
        RegisterProcessor(new EdgeProcessor());           // Priority: 70
        RegisterProcessor(new ShapeProcessor());          // Priority: 60
        RegisterProcessor(new CanvasProcessor());         // Priority: 0
    }

    public StateTransitionResult Dispatch(
        InputStateContext context,
        PointerPressedEventArgs e,
        Point canvasPosition)
    {
        // 1. Hit test using framework-agnostic interface
        var hitResult = _hitTester.HitTest(canvasPosition);

        // 2. Let behaviors intercept first
        foreach (var behavior in _behaviors.Where(b =&gt; b.IsEnabled))
        {
            var behaviorResult = behavior.OnPointerPressed(
                new GraphInputEvent(hitResult, e.KeyModifiers));

            if (behaviorResult.SuppressDefault)
                return StateTransitionResult.Stay(behaviorResult.Handled);
        }

        // 3. Find processor for this hit type
        var processor = _processors
            .OrderByDescending(p =&gt; p.Priority)
            .FirstOrDefault(p =&gt; p.HandledTypes.Contains(hitResult.TargetType));

        if (processor == null)
            return StateTransitionResult.Unhandled();

        // 4. Let processor handle
        var result = processor.HandlePointerPressed(context, hitResult, e);

        // 5. Notify behaviors of completion
        foreach (var behavior in _behaviors.Where(b =&gt; b.IsEnabled))
        {
            behavior.OnPointerPressedComplete(
                new GraphInputEvent(hitResult, e.KeyModifiers));
        }

        return new StateTransitionResult(result.NewState, result.Handled);
    }
}
</code></pre>
<h3 id="3-built-in-inputprocessors">3. Built-in InputProcessors</h3>
<p>Each processor is self-contained and focused:</p>
<pre><code class="lang-csharp">// FlowGraph.Avalonia/Input/Processors/NodeProcessor.cs
public class NodeProcessor : IInputProcessor
{
    public IReadOnlyList&lt;HitTargetType&gt; HandledTypes =&gt; new[] { HitTargetType.Node };
    public int Priority =&gt; 80;

    public InputProcessorResult HandlePointerPressed(
        InputStateContext context,
        GraphHitTestResult hit,
        PointerPressedEventArgs e)
    {
        var node = hit.Node!;  // Safe - we only handle Node hits
        var graph = context.Graph;

        if (e.ClickCount == 2 &amp;&amp; context.Settings.EnableNodeLabelEditing)
        {
            // Double-click: edit label
            context.RaiseNodeLabelEditRequested(node, hit.CanvasPosition);
            return new InputProcessorResult(null, Handled: true);
        }

        // Handle selection
        HandleSelection(context, node, e.KeyModifiers);

        // Start drag if selected and draggable
        if (node.IsSelected &amp;&amp; node.IsDraggable &amp;&amp; !context.Settings.IsReadOnly)
        {
            var dragState = new DraggingState(graph, ...);
            return new InputProcessorResult(dragState, Handled: true);
        }

        return new InputProcessorResult(null, Handled: true);
    }
}
</code></pre>
<pre><code class="lang-csharp">// FlowGraph.Avalonia/Input/Processors/ResizeHandleProcessor.cs
public class ResizeHandleProcessor : IInputProcessor
{
    // Handles BOTH node and shape resize handles!
    public IReadOnlyList&lt;HitTargetType&gt; HandledTypes =&gt; new[] { HitTargetType.ResizeHandle };
    public int Priority =&gt; 100;  // Highest - always check first

    public InputProcessorResult HandlePointerPressed(
        InputStateContext context,
        GraphHitTestResult hit,
        PointerPressedEventArgs e)
    {
        if (context.Settings.IsReadOnly)
            return new InputProcessorResult(null, Handled: false);

        var handlePosition = hit.ResizeHandle!.Value;

        // Check if it's a node or shape resize
        if (hit.ResizeHandleOwner != null)
        {
            // Node resize
            var node = hit.ResizeHandleOwner;
            var state = new ResizingState(node, handlePosition, ...);
            return new InputProcessorResult(state, Handled: true);
        }

        // Shape resize - need to extend GraphHitTestResult for shapes
        if (hit.Target is ShapeResizeHandleHitInfo shapeInfo)
        {
            var state = new ResizingShapeState(shapeInfo.Shape, handlePosition, ...);
            return new InputProcessorResult(state, Handled: true);
        }

        return new InputProcessorResult(null, Handled: false);
    }
}
</code></pre>
<h3 id="4-example-behaviors-user-extensibility">4. Example Behaviors (User Extensibility)</h3>
<pre><code class="lang-csharp">// Example: Custom behavior for multi-select with marquee
public class MarqueeSelectionBehavior : IBehavior
{
    public string Name =&gt; &quot;Marquee Selection&quot;;
    public bool IsEnabled { get; set; } = true;

    public BehaviorResult OnPointerPressed(IGraphInputEvent e)
    {
        // Only intercept Alt+Click on canvas
        if (e.HitResult.IsCanvasHit &amp;&amp; e.Modifiers.HasFlag(KeyModifiers.Alt))
        {
            // Start custom marquee mode
            StartMarquee(e.CanvasPosition);
            return new BehaviorResult(Handled: true, SuppressDefault: true);
        }

        return new BehaviorResult(Handled: false);
    }
}

// Example: Behavior that adds snap-to-grid feedback
public class SnapToGridBehavior : IBehavior
{
    public string Name =&gt; &quot;Snap to Grid&quot;;
    public bool IsEnabled { get; set; } = true;

    public BehaviorResult OnPointerPressed(IGraphInputEvent e)
    {
        // Don't intercept, just observe
        return new BehaviorResult(Handled: false);
    }

    public void OnPointerPressedComplete(IGraphInputEvent e)
    {
        // After node click, we might want to show snap guides
        if (e.HitResult.Node != null)
        {
            ShowSnapGuides(e.HitResult.Node);
        }
    }
}
</code></pre>
<hr>
<h2 id="migration-strategy">Migration Strategy</h2>
<h3 id="phase-1-add-infrastructure-non-breaking">Phase 1: Add Infrastructure (Non-Breaking)</h3>
<ol>
<li>Create <code>IInputProcessor</code> interface</li>
<li>Create <code>InputDispatcher</code> class</li>
<li>Create processor implementations that mirror current behavior</li>
<li>Wire up alongside existing code (A/B testable)</li>
</ol>
<h3 id="phase-2-migrate-idlestate">Phase 2: Migrate IdleState</h3>
<ol>
<li>Replace pattern matching in <code>IdleState.HandlePointerPressed</code> with dispatcher</li>
<li>Keep all existing state classes (DraggingState, etc.)</li>
<li>Test thoroughly</li>
</ol>
<h3 id="phase-3-add-behavior-support">Phase 3: Add Behavior Support</h3>
<ol>
<li>Create <code>IBehavior</code> interface in FlowGraph.Core</li>
<li>Create <code>IGraphInputEvent</code> abstraction</li>
<li>Add behavior registration to InputDispatcher</li>
<li>Document extensibility API</li>
</ol>
<h3 id="phase-4-cleanup">Phase 4: Cleanup</h3>
<ol>
<li>Remove deprecated pattern matching code</li>
<li>Document migration guide for custom extensions</li>
<li>Update existing states to use hit results directly</li>
</ol>
<hr>
<h2 id="benefits-of-this-design">Benefits of This Design</h2>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Current</th>
<th>Proposed</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Adding new element type</strong></td>
<td>Add pattern + handler</td>
<td>Implement IInputProcessor</td>
</tr>
<tr>
<td><strong>Forgetting a pattern</strong></td>
<td>Silent failure</td>
<td>Won't compile (must register)</td>
</tr>
<tr>
<td><strong>Custom user behaviors</strong></td>
<td>Subclass states</td>
<td>Add IBehavior</td>
</tr>
<tr>
<td><strong>Testing</strong></td>
<td>Mock entire states</td>
<td>Mock individual processors</td>
</tr>
<tr>
<td><strong>Hit testing</strong></td>
<td>Duplicated in states</td>
<td>Centralized in IGraphHitTester</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="performance-optimizations-gemini-review">Performance Optimizations (Gemini Review)</h2>
<p>Based on code review feedback, the following optimizations have been implemented:</p>
<h3 id="1-hittargettype-bitmask-flags-enum">1. HitTargetType Bitmask ([Flags] Enum)</h3>
<pre><code class="lang-csharp">[Flags]
public enum HitTargetType
{
    None = 0,
    Canvas = 1 &lt;&lt; 0,
    Node = 1 &lt;&lt; 1,
    Edge = 1 &lt;&lt; 2,
    Port = 1 &lt;&lt; 3,
    ResizeHandle = 1 &lt;&lt; 4,
    // etc.

    // Common combinations for processor registration
    All = Canvas | Node | Edge | Port | ...,
    Draggable = Node | Shape | Group,
    Selectable = Node | Edge | Shape | Group
}
</code></pre>
<p><strong>Benefit:</strong> O(1) type checking via bitwise AND instead of O(N) list iteration:</p>
<pre><code class="lang-csharp">// Before: O(N) list iteration
processor.HandledTypes.Contains(hitResult.TargetType)

// After: O(1) bitmask check
(processor.HandledTypes &amp; hitResult.TargetType) != 0
</code></pre>
<h3 id="2-pre-computed-processor-lookup">2. Pre-computed Processor Lookup</h3>
<pre><code class="lang-csharp">public class InputDispatcher
{
    // Sorted once on registration
    private readonly List&lt;IInputProcessor&gt; _processors;

    // O(1) lookup by target type
    private readonly Dictionary&lt;HitTargetType, IInputProcessor&gt; _processorLookup;

    private void RebuildLookupIfNeeded()
    {
        // Map each HitTargetType to its highest-priority processor
        foreach (HitTargetType type in Enum.GetValues&lt;HitTargetType&gt;())
        {
            var processor = _processors.FirstOrDefault(p =&gt; p.CanHandle(type));
            if (processor != null)
                _processorLookup[type] = processor;
        }
    }
}
</code></pre>
<p><strong>Benefit:</strong> Sort once on registration, O(1) dispatch instead of O(N) search.</p>
<h3 id="3-state-aware-behavior-filtering">3. State-Aware Behavior Filtering</h3>
<pre><code class="lang-csharp">public interface IBehavior
{
    /// &lt;summary&gt;
    /// The input state names this behavior is active in.
    /// If null/empty, active in all states.
    /// &lt;/summary&gt;
    IReadOnlySet&lt;string&gt;? ActiveInStates { get; }

    bool IsActiveInState(string stateName) =&gt;
        ActiveInStates == null || ActiveInStates.Contains(stateName);
}
</code></pre>
<p><strong>Benefit:</strong> Behaviors that are only relevant in specific states (e.g., selection box during Idle)
are skipped entirely in other states, avoiding unnecessary iteration on high-frequency events.</p>
<h3 id="4-pointer-capture-for-drag-operations">4. Pointer Capture for Drag Operations</h3>
<p>When a processor starts a drag operation, it <strong>MUST</strong> capture the pointer:</p>
<pre><code class="lang-csharp">e.Pointer.Capture(context.RootPanel);
</code></pre>
<p><strong>Why:</strong> If the user moves the mouse faster than the frame rate, hit tests might
return &quot;Canvas&quot; instead of the element being dragged. Pointer capture ensures
the interaction state continues receiving events regardless of visual bounds.</p>
<hr>
<h2 id="open-questions">Open Questions</h2>
<ol>
<li><p><strong>Should Behaviors be in Core or Avalonia?</strong></p>
<ul>
<li>Core: More reusable, but needs framework-agnostic event types</li>
<li>Avalonia: Simpler, but ties users to Avalonia</li>
</ul>
</li>
<li><p><strong>How to handle processor conflicts?</strong></p>
<ul>
<li>Priority ordering (current proposal)</li>
<li>Explicit chain-of-responsibility</li>
<li>Composite pattern</li>
</ul>
</li>
<li><p><strong>Should processors own their states?</strong></p>
<ul>
<li>Nodify: Yes (NodeInputProcessor has NodeIdleState, NodeDraggingState)</li>
<li>Simpler: No, shared state pool (current approach)</li>
</ul>
</li>
</ol>
<hr>
<h2 id="next-steps">Next Steps</h2>
<ol>
<li>Review this design</li>
<li>Decide on open questions</li>
<li>Create skeleton interfaces</li>
<li>Implement Phase 1 alongside existing code</li>
<li>A/B test before committing to migration</li>
</ol>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/prismify-co/FlowGraph/blob/master/docs/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          © 2026 Prismify LLC. Licensed under MIT.
        </div>
      </div>
    </footer>
  </body>
</html>
