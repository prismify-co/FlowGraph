<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Performance Optimization | FlowGraph </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Performance Optimization | FlowGraph ">
      
      
      <link rel="icon" href="../../favicon.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/prismify-co/FlowGraph/blob/master/docs/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../logo.svg" alt="FlowGraph">
            FlowGraph
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="performance-optimization">Performance Optimization</h1>

<p>FlowGraph is designed to scale from simple diagrams to complex graphs with thousands of nodes. This guide shows you how to configure FlowGraph for optimal performance at any scale.</p>
<blockquote>
<p><strong>How does FlowGraph compare?</strong> Most web-based graph editors (React Flow, JointJS) recommend limiting graphs to 500 nodes. FlowGraph's architecture supports 2000+ nodes with smooth interactions when properly configured. The techniques in this guide unlock that scale.</p>
</blockquote>
<h2 id="quick-start-optimization-presets">Quick Start: Optimization Presets</h2>
<p>For most use cases, start with these presets and adjust as needed:</p>
<pre><code class="lang-csharp">// Preset for general-purpose graphs (works well up to ~500 nodes)
public static FlowCanvasSettings Balanced() =&gt; new()
{
    EnableVirtualization = true,
    VirtualizationBuffer = 200,
    UseSimplifiedNodeRendering = false,
    AutoRouteEdges = true,
    RouteOnlyAffectedEdges = true
};

// Preset for maximum performance (2000+ nodes)
public static FlowCanvasSettings HighPerformance() =&gt; new()
{
    EnableVirtualization = true,
    VirtualizationBuffer = 100,
    UseSimplifiedNodeRendering = true,
    DirectRenderingNodeThreshold = 100,
    AutoRouteEdges = false
};
</code></pre>
<h2 id="virtualization">Virtualization</h2>
<p>Virtualization renders only visible nodes and edges, significantly improving performance for large graphs.</p>
<pre><code class="lang-csharp">// Enable virtualization (enabled by default)
canvas.Settings.EnableVirtualization = true;

// Configure buffer zone (nodes within this distance from viewport are rendered)
canvas.Settings.VirtualizationBuffer = 200; // Canvas units

// Virtualization is recommended for graphs with 100+ nodes
</code></pre>
<h3 id="when-to-use-virtualization">When to Use Virtualization</h3>
<p>Virtualization is the single most impactful optimization. It ensures only visible elements consume rendering resources.</p>
<table>
<thead>
<tr>
<th>Graph Size</th>
<th>Recommendation</th>
<th>Why</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt; 100 nodes</td>
<td>Optional</td>
<td>Overhead may not be worth it</td>
</tr>
<tr>
<td>100-500 nodes</td>
<td>Recommended</td>
<td>Noticeable improvement</td>
</tr>
<tr>
<td>500+ nodes</td>
<td>Essential</td>
<td>Critical for smooth interactions</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>Pro tip:</strong> Set <code>VirtualizationBuffer</code> based on your node sizes. Larger nodes need larger buffers to avoid pop-in during fast panning.</p>
</blockquote>
<h2 id="simplified-node-rendering">Simplified Node Rendering</h2>
<p>For graphs with hundreds of nodes, use simplified rendering to reduce visual tree complexity:</p>
<pre><code class="lang-csharp">// Enable simplified rendering
canvas.EnableSimplifiedRendering();

// This replaces node renderers with minimal visual elements
// - Single Border + TextBlock per node
// - No shadows, gradients, or complex effects
// - Significantly faster rendering

// Disable when needed
canvas.DisableSimplifiedRendering();

// Or configure via settings
canvas.Settings.UseSimplifiedNodeRendering = true;
canvas.Settings.RenderBatchSize = 50; // Render in batches to keep UI responsive
</code></pre>
<h2 id="direct-gpu-rendering">Direct GPU Rendering</h2>
<p>For very large graphs, FlowGraph can bypass the Avalonia visual tree and render directly to the GPU. This is how professional diagramming tools achieve smooth performance with thousands of elements.</p>
<pre><code class="lang-csharp">// Enable direct rendering
canvas.EnableDirectRendering();

// This mode:
// - Draws nodes/edges directly to DrawingContext
// - Bypasses visual tree overhead
// - Trades some interactivity for performance
// - Ideal for 500+ nodes

// Automatically enables at threshold
canvas.Settings.DirectRenderingNodeThreshold = 100;

// Disable direct rendering
canvas.DisableDirectRendering();
</code></pre>
<h3 id="what-you-keep-vs-what-changes">What You Keep vs. What Changes</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Standard Mode</th>
<th>Direct Rendering</th>
</tr>
</thead>
<tbody>
<tr>
<td>Pan/Zoom</td>
<td>✅ Full</td>
<td>✅ Full</td>
</tr>
<tr>
<td>Node dragging</td>
<td>✅ Full</td>
<td>✅ Full</td>
</tr>
<tr>
<td>Edge connections</td>
<td>✅ Full</td>
<td>✅ Full</td>
</tr>
<tr>
<td>Selection</td>
<td>✅ Full</td>
<td>✅ Full</td>
</tr>
<tr>
<td>Hover effects</td>
<td>✅ Animated</td>
<td>⚡ Simplified</td>
</tr>
<tr>
<td>Custom controls in nodes</td>
<td>✅ Full</td>
<td>❌ Not supported</td>
</tr>
<tr>
<td>Animations</td>
<td>✅ Full</td>
<td>⚡ Basic</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>When to use:</strong> Enable direct rendering when you need smooth interactions with 500+ nodes and don't require embedded controls (buttons, text inputs) inside nodes. Most workflow and diagram applications work perfectly in this mode.</p>
</blockquote>
<h2 id="batch-loading">Batch Loading</h2>
<p>When initially loading a large graph, use batch operations to suppress individual change notifications:</p>
<pre><code class="lang-csharp">using FlowGraph.Core;

// Method 1: Batch load mode
graph.BeginBatchLoad();
try
{
    for (int i = 0; i &lt; 10000; i++)
    {
        graph.AddNode(CreateNode(i));
    }

    for (int i = 0; i &lt; 20000; i++)
    {
        graph.AddEdge(CreateEdge(i));
    }
}
finally
{
    graph.EndBatchLoad(); // Single notification at end
}

// Method 2: Bulk operations
var nodes = Enumerable.Range(0, 10000).Select(CreateNode);
var edges = Enumerable.Range(0, 20000).Select(CreateEdge);

graph.AddNodes(nodes); // Single notification
graph.AddEdges(edges); // Single notification
</code></pre>
<h2 id="edge-routing-performance">Edge Routing Performance</h2>
<p>Edge routing (calculating paths that avoid overlapping nodes) is computationally intensive. Here's how to optimize it without losing functionality:</p>
<pre><code class="lang-csharp">// Strategy 1: Defer routing during load
canvas.Settings.AutoRouteEdges = false;
LoadLargeGraph();
canvas.Settings.AutoRouteEdges = true;
canvas.Routing.RouteAllEdges(); // Single batch operation

// Strategy 2: Route only what changed
canvas.Settings.RouteOnlyAffectedEdges = true; // Only re-route edges connected to moved nodes

// Strategy 3: Disable re-routing during drag (route on drop)
canvas.Settings.RouteEdgesOnDrag = false;

// Strategy 4: Use simpler routing for large graphs
canvas.Settings.EdgeRoutingAlgorithm = RouterAlgorithm.Direct; // Straight lines
// or
canvas.Settings.EdgeRoutingAlgorithm = RouterAlgorithm.Bezier; // Simple curves
// vs.
canvas.Settings.EdgeRoutingAlgorithm = RouterAlgorithm.SmartBezier; // Obstacle avoidance (slower)
</code></pre>
<h3 id="routing-algorithm-comparison">Routing Algorithm Comparison</h3>
<table>
<thead>
<tr>
<th>Algorithm</th>
<th>Speed</th>
<th>Visual Quality</th>
<th>Node Avoidance</th>
</tr>
</thead>
<tbody>
<tr>
<td>Direct</td>
<td>⚡⚡⚡ Fastest</td>
<td>Basic</td>
<td>No</td>
</tr>
<tr>
<td>Bezier</td>
<td>⚡⚡ Fast</td>
<td>Good</td>
<td>No</td>
</tr>
<tr>
<td>Orthogonal</td>
<td>⚡ Medium</td>
<td>Clean</td>
<td>Yes</td>
</tr>
<tr>
<td>SmartBezier</td>
<td>Slower</td>
<td>Best</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>Recommendation:</strong> Use <code>SmartBezier</code> for graphs under 200 edges where visual clarity matters. Use <code>Bezier</code> or <code>Direct</code> for larger graphs.</p>
</blockquote>
<h2 id="recommended-settings-by-graph-size">Recommended Settings by Graph Size</h2>
<p>These configurations have been tested for optimal balance of features and performance.</p>
<h3 id="small-graphs--100-nodes">Small Graphs (&lt; 100 nodes)</h3>
<p>Full features, no compromises needed.</p>
<pre><code class="lang-csharp">var settings = new FlowCanvasSettings
{
    EnableVirtualization = false, // Not needed
    UseSimplifiedNodeRendering = false,
    DirectRenderingNodeThreshold = 0, // Disabled
    AutoRouteEdges = true,
    RouteEdgesOnDrag = true,
    EdgeRoutingAlgorithm = RouterAlgorithm.SmartBezier
};
</code></pre>
<h3 id="medium-graphs-100-500-nodes">Medium Graphs (100-500 nodes)</h3>
<p>Enable virtualization, keep full interactivity.</p>
<pre><code class="lang-csharp">var settings = new FlowCanvasSettings
{
    EnableVirtualization = true,
    VirtualizationBuffer = 200,
    UseSimplifiedNodeRendering = false,
    DirectRenderingNodeThreshold = 300, // Auto-enable if needed
    AutoRouteEdges = true,
    RouteEdgesOnDrag = true,
    RouteOnlyAffectedEdges = true,
    EdgeRoutingAlgorithm = RouterAlgorithm.Bezier
};
</code></pre>
<h3 id="large-graphs-500-2000-nodes">Large Graphs (500-2000 nodes)</h3>
<p>Optimized rendering, selective routing.</p>
<pre><code class="lang-csharp">var settings = new FlowCanvasSettings
{
    EnableVirtualization = true,
    VirtualizationBuffer = 150,
    UseSimplifiedNodeRendering = true,
    RenderBatchSize = 50,
    DirectRenderingNodeThreshold = 100,
    AutoRouteEdges = true,
    RouteEdgesOnDrag = false, // Route on drop instead
    RouteOnlyAffectedEdges = true,
    EdgeRoutingAlgorithm = RouterAlgorithm.Bezier
};

canvas.Settings = settings;
canvas.EnableSimplifiedRendering();
</code></pre>
<h3 id="very-large-graphs-2000-nodes">Very Large Graphs (2000+ nodes)</h3>
<p>Maximum performance mode. Full pan/zoom/selection, simplified visuals.</p>
<pre><code class="lang-csharp">var settings = new FlowCanvasSettings
{
    EnableVirtualization = true,
    VirtualizationBuffer = 100,
    UseSimplifiedNodeRendering = true,
    RenderBatchSize = 100,
    DirectRenderingNodeThreshold = 50,
    AutoRouteEdges = false, // On-demand routing
    RouteEdgesOnDrag = false,
    EdgeRoutingAlgorithm = RouterAlgorithm.Direct
};

canvas.Settings = settings;
canvas.EnableDirectRendering();

// Route edges on-demand when user selects nodes
canvas.SelectionChanged += (s, e) =&gt;
{
    if (e.AddedNodes.Any())
        canvas.Routing.RouteEdgesForNodes(e.AddedNodes);
};
</code></pre>
<h2 id="performance-monitoring">Performance Monitoring</h2>
<p>Use the FlowDiagnostics control to monitor performance:</p>
<pre><code class="lang-xml">&lt;fgc:FlowPanel Position=&quot;TopLeft&quot; Margin=&quot;8&quot;&gt;
    &lt;fgc:FlowDiagnostics TargetCanvas=&quot;{Binding #Canvas}&quot; /&gt;
&lt;/fgc:FlowPanel&gt;
</code></pre>
<p>The diagnostics panel shows:</p>
<ul>
<li>Node count (visible/total)</li>
<li>Edge count (visible/total)</li>
<li>Render time</li>
<li>Frame rate</li>
<li>Viewport info</li>
<li>Current input state</li>
</ul>
<h2 id="best-practices">Best Practices</h2>
<h3 id="loading-large-graphs">Loading Large Graphs</h3>
<ol>
<li><p><strong>Use batch operations</strong> - Always use <code>AddNodes()</code> / <code>AddEdges()</code> instead of loops with individual <code>AddNode()</code> / <code>AddEdge()</code> calls</p>
</li>
<li><p><strong>Disable animations during load</strong> - Prevents rendering overhead during initial population</p>
</li>
<li><p><strong>Defer routing</strong> - Disable <code>AutoRouteEdges</code> during load, enable after</p>
</li>
</ol>
<pre><code class="lang-csharp">// Optimized loading pattern
public async Task LoadGraphOptimized(IEnumerable&lt;Node&gt; nodes, IEnumerable&lt;Edge&gt; edges)
{
    // Prepare canvas
    canvas.Settings.AutoRouteEdges = false;
    canvas.BeginBatchUpdate();

    try
    {
        // Batch add - triggers single notification
        graph.AddNodes(nodes);
        graph.AddEdges(edges);
    }
    finally
    {
        canvas.EndBatchUpdate();
    }

    // Fit view and route
    canvas.FitToView();
    canvas.Settings.AutoRouteEdges = true;
}
</code></pre>
<h3 id="custom-node-renderers">Custom Node Renderers</h3>
<p>If you're creating custom node renderers, keep them lightweight:</p>
<pre><code class="lang-csharp">// ❌ Avoid: Complex visual tree
public override Control CreateVisual(Node node)
{
    return new Border
    {
        Child = new StackPanel
        {
            Children =
            {
                new Border { Child = new TextBlock { /* header */ } },
                new ItemsControl { /* ports */ },
                new Border { Child = new ContentPresenter { /* content */ } }
            }
        }
    };
}

// ✅ Better: Flat structure
public override Control CreateVisual(Node node)
{
    return new NodeControl(node); // Single custom control
}

// ✅ Best: Direct rendering
public override void Render(DrawingContext context, Node node)
{
    // Draw directly - no visual tree overhead
    context.DrawRectangle(brush, pen, bounds);
    context.DrawText(formattedText, position);
}
</code></pre>
<h3 id="data-management">Data Management</h3>
<p>Store large payloads outside the graph:</p>
<pre><code class="lang-csharp">// ❌ Avoid: Large data in node
node.Data = new {
    Image = LoadBitmap(),      // Large!
    Document = LoadXml(),      // Large!
    Metadata = complexObject   // Serialization overhead
};

// ✅ Better: Reference by ID
node.Data = new NodeData {
    ImageId = &quot;img-123&quot;,
    DocumentId = &quot;doc-456&quot;
};

// Load on demand
var image = await imageCache.GetAsync(nodeData.ImageId);
</code></pre>
<h3 id="profiling-tips">Profiling Tips</h3>
<ol>
<li><strong>Profile first</strong> - Use FlowDiagnostics to identify actual bottlenecks before optimizing</li>
<li><strong>Check visible counts</strong> - If visible nodes &lt;&lt; total nodes, virtualization is working</li>
<li><strong>Monitor render time</strong> - Should be &lt; 16ms for 60fps</li>
<li><strong>Watch memory</strong> - Growing memory indicates caching issues</li>
</ol>
<h2 id="async-loading-example">Async Loading Example</h2>
<pre><code class="lang-csharp">public async Task LoadLargeGraphAsync(string filePath)
{
    // Disable rendering updates
    canvas.Settings.AutoRouteEdges = false;

    // Load graph data
    var graph = await GraphExtensions.LoadFromFileAsync(filePath);

    // Show progress
    var progress = new Progress&lt;int&gt;(value =&gt;
    {
        ProgressBar.Value = value;
    });

    // Batch load into canvas
    graph.BeginBatchLoad();

    // Could add nodes in chunks here if needed
    // for better responsiveness

    graph.EndBatchLoad();

    // Set graph
    canvas.Graph = graph;

    // Fit to view after load
    await Task.Delay(100); // Allow layout
    canvas.FitToView();

    // Re-enable routing if needed
    canvas.Settings.AutoRouteEdges = true;
}
</code></pre>
<h2 id="memory-management">Memory Management</h2>
<p>For long-running applications:</p>
<pre><code class="lang-csharp">// Clear graph when switching documents
canvas.Graph = null;

// Force garbage collection if needed
GC.Collect();
GC.WaitForPendingFinalizers();
GC.Collect();

// Dispose of custom resources in node Data property
foreach (var node in graph.Nodes)
{
    if (node.Data is IDisposable disposable)
        disposable.Dispose();
}
</code></pre>
<h2 id="summary">Summary</h2>
<p>FlowGraph scales from small diagrams to enterprise-grade graphs with thousands of nodes. The key is matching your configuration to your graph size.</p>
<table>
<thead>
<tr>
<th>Graph Size</th>
<th>Virtualization</th>
<th>Simplified Rendering</th>
<th>Direct Rendering</th>
<th>Edge Routing</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt; 100</td>
<td>Optional</td>
<td>No</td>
<td>No</td>
<td>Full (SmartBezier)</td>
</tr>
<tr>
<td>100-500</td>
<td>Yes</td>
<td>Optional</td>
<td>Optional</td>
<td>Full (Bezier)</td>
</tr>
<tr>
<td>500-2000</td>
<td>Yes</td>
<td>Recommended</td>
<td>Recommended</td>
<td>Selective</td>
</tr>
<tr>
<td>2000+</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>On-Demand</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>Remember:</strong> These are recommendations, not limitations. FlowGraph's architecture supports all configurations—you choose the balance of features and performance that fits your application.</p>
</blockquote>
<h3 id="common-scenarios">Common Scenarios</h3>
<table>
<thead>
<tr>
<th>Use Case</th>
<th>Recommended Config</th>
<th>Why</th>
</tr>
</thead>
<tbody>
<tr>
<td>Node-based editor (Blender-style)</td>
<td>Balanced</td>
<td>Need interactive nodes with controls</td>
</tr>
<tr>
<td>Workflow designer</td>
<td>Balanced</td>
<td>Moderate size, full features</td>
</tr>
<tr>
<td>Network topology viewer</td>
<td>High Performance</td>
<td>Large graphs, read-mostly</td>
</tr>
<tr>
<td>Data lineage visualization</td>
<td>High Performance</td>
<td>Thousands of nodes, minimal editing</td>
</tr>
<tr>
<td>Mind mapping</td>
<td>Balanced</td>
<td>Interactive, moderate size</td>
</tr>
</tbody>
</table>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/prismify-co/FlowGraph/blob/master/docs/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          2026 Prismify LLC. Licensed under MIT.
        </div>
      </div>
    </footer>
  </body>
</html>
