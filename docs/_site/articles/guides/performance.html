<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Performance Optimization | FlowGraph </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Performance Optimization | FlowGraph ">
      
      
      <link rel="icon" href="../../favicon.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/prismify-co/FlowGraph/blob/master/docs/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../logo.svg" alt="FlowGraph">
            FlowGraph
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="performance-optimization">Performance Optimization</h1>

<p>FlowGraph includes several performance features to handle large graphs efficiently.</p>
<h2 id="virtualization">Virtualization</h2>
<p>Virtualization renders only visible nodes and edges, significantly improving performance for large graphs.</p>
<pre><code class="lang-csharp">// Enable virtualization (enabled by default)
canvas.Settings.EnableVirtualization = true;

// Configure buffer zone (nodes within this distance from viewport are rendered)
canvas.Settings.VirtualizationBuffer = 200; // Canvas units

// Virtualization is recommended for graphs with 100+ nodes
</code></pre>
<h3 id="when-to-use-virtualization">When to Use Virtualization</h3>
<ul>
<li><strong>Small graphs (&lt; 100 nodes)</strong>: Optional, overhead may outweigh benefits</li>
<li><strong>Medium graphs (100-500 nodes)</strong>: Recommended</li>
<li><strong>Large graphs (500+ nodes)</strong>: Essential</li>
</ul>
<h2 id="simplified-node-rendering">Simplified Node Rendering</h2>
<p>For graphs with hundreds of nodes, use simplified rendering to reduce visual tree complexity:</p>
<pre><code class="lang-csharp">// Enable simplified rendering
canvas.EnableSimplifiedRendering();

// This replaces node renderers with minimal visual elements
// - Single Border + TextBlock per node
// - No shadows, gradients, or complex effects
// - Significantly faster rendering

// Disable when needed
canvas.DisableSimplifiedRendering();

// Or configure via settings
canvas.Settings.UseSimplifiedNodeRendering = true;
canvas.Settings.RenderBatchSize = 50; // Render in batches to keep UI responsive
</code></pre>
<h2 id="direct-gpu-rendering">Direct GPU Rendering</h2>
<p>For very large graphs, FlowGraph can bypass the Avalonia visual tree and render directly to the GPU:</p>
<pre><code class="lang-csharp">// Enable direct rendering
canvas.EnableDirectRendering();

// This mode:
// - Draws nodes/edges directly to DrawingContext
// - Bypasses visual tree overhead
// - Trades interactivity for performance
// - Best for 500+ nodes

// Automatically enables at threshold
canvas.Settings.DirectRenderingNodeThreshold = 100;

// Disable direct rendering
canvas.DisableDirectRendering();
</code></pre>
<h3 id="direct-rendering-trade-offs">Direct Rendering Trade-offs</h3>
<p><strong>Advantages:</strong></p>
<ul>
<li>10-100x faster rendering for large graphs</li>
<li>Lower memory usage</li>
<li>Smooth panning and zooming</li>
</ul>
<p><strong>Limitations:</strong></p>
<ul>
<li>Reduced interactivity (hover effects, animations)</li>
<li>No custom node controls (buttons, inputs)</li>
<li>Basic visual styling only</li>
</ul>
<h2 id="batch-loading">Batch Loading</h2>
<p>When initially loading a large graph, use batch operations to suppress individual change notifications:</p>
<pre><code class="lang-csharp">using FlowGraph.Core;

// Method 1: Batch load mode
graph.BeginBatchLoad();
try
{
    for (int i = 0; i &lt; 10000; i++)
    {
        graph.AddNode(CreateNode(i));
    }

    for (int i = 0; i &lt; 20000; i++)
    {
        graph.AddEdge(CreateEdge(i));
    }
}
finally
{
    graph.EndBatchLoad(); // Single notification at end
}

// Method 2: Bulk operations
var nodes = Enumerable.Range(0, 10000).Select(CreateNode);
var edges = Enumerable.Range(0, 20000).Select(CreateEdge);

graph.AddNodes(nodes); // Single notification
graph.AddEdges(edges); // Single notification
</code></pre>
<h2 id="edge-routing-performance">Edge Routing Performance</h2>
<p>Edge routing can be expensive for large graphs. Configure it wisely:</p>
<pre><code class="lang-csharp">// Disable routing during initial load
canvas.Settings.AutoRouteEdges = false;

// Load graph...
LoadLargeGraph();

// Enable routing after load
canvas.Settings.AutoRouteEdges = true;
canvas.Routing.RouteAllEdges();

// Performance options
canvas.Settings.RouteEdgesOnDrag = false; // Disable re-routing during drag
canvas.Settings.RouteOnlyAffectedEdges = true; // Only re-route connected edges
canvas.Settings.RouteNewEdges = true; // Auto-route new connections
</code></pre>
<h2 id="recommended-settings-by-graph-size">Recommended Settings by Graph Size</h2>
<h3 id="small-graphs--100-nodes">Small Graphs (&lt; 100 nodes)</h3>
<pre><code class="lang-csharp">var settings = new FlowCanvasSettings
{
    EnableVirtualization = false, // Not needed
    UseSimplifiedNodeRendering = false,
    DirectRenderingNodeThreshold = 0, // Disabled
    AutoRouteEdges = true,
    RouteEdgesOnDrag = true
};
</code></pre>
<h3 id="medium-graphs-100-500-nodes">Medium Graphs (100-500 nodes)</h3>
<pre><code class="lang-csharp">var settings = new FlowCanvasSettings
{
    EnableVirtualization = true,
    VirtualizationBuffer = 200,
    UseSimplifiedNodeRendering = false,
    DirectRenderingNodeThreshold = 300,
    AutoRouteEdges = true,
    RouteEdgesOnDrag = true,
    RouteOnlyAffectedEdges = true
};
</code></pre>
<h3 id="large-graphs-500-2000-nodes">Large Graphs (500-2000 nodes)</h3>
<pre><code class="lang-csharp">var settings = new FlowCanvasSettings
{
    EnableVirtualization = true,
    VirtualizationBuffer = 150,
    UseSimplifiedNodeRendering = true,
    RenderBatchSize = 50,
    DirectRenderingNodeThreshold = 100,
    AutoRouteEdges = false, // Manual routing
    RouteEdgesOnDrag = false,
    RouteOnlyAffectedEdges = true
};

canvas.Settings = settings;
canvas.EnableSimplifiedRendering();
</code></pre>
<h3 id="very-large-graphs-2000-nodes">Very Large Graphs (2000+ nodes)</h3>
<pre><code class="lang-csharp">var settings = new FlowCanvasSettings
{
    EnableVirtualization = true,
    VirtualizationBuffer = 100,
    UseSimplifiedNodeRendering = true,
    RenderBatchSize = 100,
    DirectRenderingNodeThreshold = 50,
    AutoRouteEdges = false,
    RouteEdgesOnDrag = false
};

canvas.Settings = settings;
canvas.EnableDirectRendering();
</code></pre>
<h2 id="performance-monitoring">Performance Monitoring</h2>
<p>Use the FlowDiagnostics control to monitor performance:</p>
<pre><code class="lang-xml">&lt;fgc:FlowPanel Position=&quot;TopLeft&quot; Margin=&quot;8&quot;&gt;
    &lt;fgc:FlowDiagnostics TargetCanvas=&quot;{Binding #Canvas}&quot; /&gt;
&lt;/fgc:FlowPanel&gt;
</code></pre>
<p>The diagnostics panel shows:</p>
<ul>
<li>Node count (visible/total)</li>
<li>Edge count (visible/total)</li>
<li>Render time</li>
<li>Frame rate</li>
<li>Viewport info</li>
<li>Current input state</li>
</ul>
<h2 id="best-practices">Best Practices</h2>
<ol>
<li><p><strong>Use batch operations</strong> - Always use <code>AddNodes()</code> / <code>AddEdges()</code> instead of loops with <code>AddNode()</code> / <code>AddEdge()</code></p>
</li>
<li><p><strong>Load progressively</strong> - For very large graphs, consider lazy loading or pagination</p>
</li>
<li><p><strong>Disable animations</strong> - During initial load, disable animations for faster rendering</p>
</li>
<li><p><strong>Profile first</strong> - Use FlowDiagnostics to identify bottlenecks before optimizing</p>
</li>
<li><p><strong>Consider data</strong> - Store large custom data outside the graph, reference by ID</p>
</li>
<li><p><strong>Simplify renderers</strong> - Custom node renderers should be as simple as possible</p>
</li>
<li><p><strong>Edge routing</strong> - Disable during load, enable only if needed</p>
</li>
<li><p><strong>Viewport bounds</strong> - Set reasonable bounds to prevent infinite panning</p>
</li>
</ol>
<h2 id="async-loading-example">Async Loading Example</h2>
<pre><code class="lang-csharp">public async Task LoadLargeGraphAsync(string filePath)
{
    // Disable rendering updates
    canvas.Settings.AutoRouteEdges = false;

    // Load graph data
    var graph = await GraphExtensions.LoadFromFileAsync(filePath);

    // Show progress
    var progress = new Progress&lt;int&gt;(value =&gt;
    {
        ProgressBar.Value = value;
    });

    // Batch load into canvas
    graph.BeginBatchLoad();

    // Could add nodes in chunks here if needed
    // for better responsiveness

    graph.EndBatchLoad();

    // Set graph
    canvas.Graph = graph;

    // Fit to view after load
    await Task.Delay(100); // Allow layout
    canvas.FitToView();

    // Re-enable routing if needed
    canvas.Settings.AutoRouteEdges = true;
}
</code></pre>
<h2 id="memory-management">Memory Management</h2>
<p>For long-running applications:</p>
<pre><code class="lang-csharp">// Clear graph when switching documents
canvas.Graph = null;

// Force garbage collection if needed
GC.Collect();
GC.WaitForPendingFinalizers();
GC.Collect();

// Dispose of custom resources in node Data property
foreach (var node in graph.Nodes)
{
    if (node.Data is IDisposable disposable)
        disposable.Dispose();
}
</code></pre>
<h2 id="summary">Summary</h2>
<table>
<thead>
<tr>
<th>Graph Size</th>
<th>Virtualization</th>
<th>Simplified Rendering</th>
<th>Direct Rendering</th>
<th>Edge Routing</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt; 100</td>
<td>Optional</td>
<td>No</td>
<td>No</td>
<td>Full</td>
</tr>
<tr>
<td>100-500</td>
<td>Yes</td>
<td>Optional</td>
<td>Optional</td>
<td>Full</td>
</tr>
<tr>
<td>500-2000</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Limited</td>
</tr>
<tr>
<td>2000+</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Manual</td>
</tr>
</tbody>
</table>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/prismify-co/FlowGraph/blob/master/docs/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          2026 Prismify LLC. Licensed under MIT.
        </div>
      </div>
    </footer>
  </body>
</html>
